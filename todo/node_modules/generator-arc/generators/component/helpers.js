'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceNameInPascalResource = exports.findPascalPaths = exports.getInfoFromPascalPath = exports.getFolderFromPascalPath = exports.isDir = exports.getNameFromPascalPath = exports.getNormalizedPascalPath = undefined;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// this function works, but might be hard to read, please refer to tests and comments
// contributions to improve readability are welcome
var getNormalizedPascalPath = exports.getNormalizedPascalPath = function getNormalizedPascalPath(pascalPath) {
  var hasPascal = void 0;

  var parts = pascalPath.split('/').map(function (part) {
    return {
      // given 'foo.bar.baz', then name = 'foo', ext = 'baz'
      name: part.replace(/([^.]+)\..+$/, '$1'),
      ext: _path2.default.extname(part)
    };
  });

  return _lodash2.default.uniqWith(parts, function (a, b) {
    // ensure that Pascal parts are unique so paths like Button/Button.js will fallback to Button/
    return a.name === b.name && /^[A-Z]/.test(a.name);
  }).reverse().reduce(function (prev, curr, i, array) {
    // if found a Pascal, add everything that comes after like foo/bar/Button/
    // we are iterating reversely so Button/ would come first
    if (hasPascal) {
      return curr.name + (curr.ext || '/') + prev;
    }
    if (/^[A-Z]/.test(curr.name)) {
      // set hasPascal flag
      hasPascal = true;
      return curr.name + (curr.ext || '/') + prev;
    }
    return prev;
  }, '');
};

var getNameFromPascalPath = exports.getNameFromPascalPath = function getNameFromPascalPath(pascalPath) {
  // foo/bar/Baz.js to Baz
  return pascalPath.split('/').reduce(function (prev, curr) {
    if (/^[A-Z]/.test(curr)) {
      return curr.replace(/\/|\.[^.]*$/, '');
    }
    return prev;
  }, '');
};

var isDir = exports.isDir = function isDir(pascalPath) {
  return (/\/$/.test(pascalPath)
  );
};

var getFolderFromPascalPath = exports.getFolderFromPascalPath = function getFolderFromPascalPath(pascalPath) {
  var name = getNameFromPascalPath(pascalPath);
  var extension = _path2.default.extname(pascalPath);
  return pascalPath.replace(new RegExp('/?' + name + extension + '/?'), '') || '.';
};

var getInfoFromPascalPath = exports.getInfoFromPascalPath = function getInfoFromPascalPath(pascalPath, baseUrl) {
  return {
    name: getNameFromPascalPath(pascalPath),
    isDir: isDir(pascalPath),
    extension: _path2.default.extname(pascalPath),
    folder: getFolderFromPascalPath(pascalPath),
    url: baseUrl && baseUrl.replace ? baseUrl.replace(/\/$/, '') + '/' + pascalPath : pascalPath,
    path: pascalPath
  };
};

var findPascalPaths = exports.findPascalPaths = function findPascalPaths(cwd, prependPath) {
  var pattern = '**/[A-Z]{*/*.,*.,.}{js,jsx,ts}';
  var ignore = ['**/node_modules/**'];
  return _glob2.default.sync(pattern, { cwd: cwd, ignore: ignore }).reduce(function (array, currentPath) {
    var normalizedPath = getNormalizedPascalPath(prependPath && prependPath.replace ? prependPath.replace(/\/$/, '') + '/' + currentPath : currentPath);
    if (array.indexOf(normalizedPath) < 0) {
      array.push(normalizedPath);
    }
    return array;
  }, []);
};

var replaceNameInPascalResource = exports.replaceNameInPascalResource = function replaceNameInPascalResource(contents, oldName, newName) {
  return contents.replace(new RegExp('([^a-zA-Z0-9_$])' + oldName + '([^a-zA-Z0-9_$]|Container)', 'g'), '$1' + newName + '$2');
};